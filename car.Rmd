---
title: "car"
author: "Carbone Giorgio, Scuri Gianluca, Gazzola Michele"
date: "12/11/2021"
output:
  html_document: default
  pdf_document: default
---

``` {r installazione pacchetti, include = FALSE}

```
### Importazione librerie
- Importo le librerie necessarie all'esecuzione del codice
```{r importazione librerie e opzioni di rendering, include=FALSE}
library(readr)
library(tibble)
library(dplyr)
library(stringr)

library(mice)
#library(caret)
#library(ggcorrplot)
#library(ggrepel)
#library(gridExtra)
#library(glmnet)
#library(xgboost)
#library(printr)
#library(lemon)
#knit_print.data.frame <- lemon_print
```

# Lettura Dataset
- Vengono assegnati i fase di lettura i tipi corretti ad ogni variabile
- Alcune variabili presentano l'unità di misura espressa nel valore, vengono
quindi temporanemanente definiti come stringhe
```{r importazione}
data_path <- "https://raw.githubusercontent.com/giocoal/datasets/main/Car%20details%20v3.csv"
car <- read_csv(data_path, col_types = 'ciiiffff????i')
head(data.frame(car))
View(car)
#is_tibble(car) Verifico che il ds sia di tipo tibble
```

# Fase di osservazione del dataset
``` {r lettura}
str(car, give.attr = F)
summary(car)
```
- Il dataset ha 8123 unità statistiche e 13 attributi

### Scegliamo di non considerare i seguenti attributi

- Scegliamo di non considerare la colonna mileage (consumi) perchè
I consumi delle auto con diverso combustibile non sono comparabili perchè i combustibili hanno un diverso rapporto tra energia generata/unità di volume
- L'attributo torque, in quanto calcolato a rpm diversi per ogni veicolo/marca, lo escludiamo dall'analisi
```{r rimozione colonna torque e mileage}
car <- select(car, -c(torque,mileage))
head(car)
```


# Sistemo alcuni missing values che sono stati memorizzati come "zeri" (da mettere nella sez outlier?)
```{r from 0 to NA}
car$max_power[car$max_power == "bhp"] <- NA
#car$max_power[car$max_power == 0 | car$max_power == "bhp"] <- NA
#car$mileage[car$mileage == "0.0 kmpl"] <- NA
```


# Verifico che le unitá di misura di ogni singolo attributo siano consistenti tra loro
```{r Controllo unita di misura}
#all(grepl("kmpl", car$mileage) == !is.na(car$mileage))
#Viene FALSE perché:
#le macchine a Gas di petrolio liquefatto (LPG) e quelle a Metano (CNG) misurano il mileage in km/kg

all(grepl("CC", car$engine) == !is.na(car$engine))
#viene TRUE quindi sono tutti consistenti

all((grepl("bhp", car$max_power)) == !is.na(car$max_power))
#viene TRUE quindi sono tutti consistenti
```
``` {r conteggio km/kg vs kmpl, possibile ipotesi di eliminare le righe dei GPL e CNG}
# Il numero di auto valore di mileage in kmpl è solo di 88 (contro 7802)
#sum(grepl("kmpl", car$mileage))
#sum(grepl("km/kg", car$mileage))
# Valore coerente con il numero totale di auto a LPG e CNG (95, probabilmente la differenza sono na)
#cat("Numero di auto LPG o CNG:", sum(table(car$fuel)[c(3, 4)]))
# Propongo di non considerare le auto a gpl e cng, dato il numero esiguo di unità statistiche
# e un possibile problema correlato al fatto che queste auto non siano sufficientemente rappresentate
#car <- subset(car, fuel != "LPG" & fuel != "CNG")
```

# Convesione nelle stringhe 'Valore Unità_Di_Misura' in valori numerici privi di udm
```{r Eliminazione unità di misura}
# Creo un nuovo attributo dei soli valori privi di unità di misura
# includo l'unità di misura nel nome della variabile
# La funzione parse_number mantiene i NA tali e converte tutte quelle
# celle prive di numeri in NA
#car['mileage(kmpl)'] <- parse_number(car$mileage)
car['engine(CC)'] <- parse_number(car$engine)
car['max_power(bhp)'] <- parse_number(car$max_power)
# Elimino le colonne con unità di misura usando la funzione select() di dplyr
#car <- select(car, -c('mileage', 'engine', 'max_power'))
car <- select(car, -c('engine', 'max_power'))
# Alternativa è creare una colonna di fattori 0 e 1 che indicano l'unità di misura
# Ma mi sembra un po' eccessivo dato il numero esiguo di unità statistiche
```
### Creazione di una colonna contenente la marca dell'auto
```{r colonna marca}
# Uso la funzione word della libreria dplyr
# la funzione add_column di tibble peraggiunge la nuova colonna dopo la colonna name
car <- add_column(car, make = factor(word(car$name, 1)), .after = "name")
```

#### Missing Value Gio
```{r missing value}
# md.pattern (del pacchetto mice), è una funzione di visualizzazione molto utile
# Permette di vedere la distribuzione di NA 
# nonchè di classificare le righe in funzione del numero di NA che contengono
md.pattern(car, rotate.names=TRUE)
```
```{r test}
head(car)
```
# Missing Value
``` {r Missing Values}
for (i in names(car)) {
  print(i)
  print(sum(is.na(car[i])))
}

#numero di righe con almeno un NA
sum(!complete.cases(car))

#Trattandosi di 239 righe possiamo pensare di rimuoverle dato che costituiscono circa il 3% del dataset

#qui bisogna aggiungere la funzione per rimuovere le righe
#car <- car[-which(!complete.cases(car)),]
```
# istogrammi e box plot
``` {r istogrammi e box plot, include = False}
#boxplot
for (i in 1:ncol(car)) {
  boxplot(car[,i], main = colnames(car)[i])
}


#istogrammi
for (i in 1:ncol(car)) {
  hist(car[,i], main = colnames(car)[i])
}
```
